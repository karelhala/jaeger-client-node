{"version":3,"sources":["../../../test/samplers/guaranteed_throughput_sampler.js"],"names":["describe","it","sampler","equal","name","callback","spy","close","calledOnce","isFalse","isOk","expectedTags","forEach","expectedDecision","actualTags","decision","isSampled","deepEqual","isNotOk","assertValues","lb","rate","_lowerBoundSampler","maxTracesPerSecond","_probabilisticSampler","samplingRate","p1","p2","isUpdated","update","strictEqual","isTrue","expectedTagsLB","expectedTagsProb","num","probability","sampled","tags","testCase","s"],"mappings":"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","file":"guaranteed_throughput_sampler.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {assert} from 'chai';\nimport sinon from 'sinon';\nimport ConstSampler from '../../src/samplers/const_sampler';\nimport GuaranteedThroughputSampler from '../../src/samplers/guaranteed_throughput_sampler';\n\ndescribe('GuaranteedThroughput sampler', () => {\n    it('should have a name and be closable', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 0);\n        assert.equal(sampler.name(), 'GuaranteedThroughputSampler');\n\n        let callback = sinon.spy();\n        sampler.close(callback);\n        assert(callback.calledOnce);\n    });\n\n    it('should not equal other types', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 0);\n        assert.isFalse(sampler.equal(new ConstSampler(true)));\n        sampler.close();\n    });\n\n    it('should equal itself', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 0);\n        assert.isOk(sampler.equal(sampler));\n        assert.isOk(sampler.equal(new GuaranteedThroughputSampler(2, 0)));\n        sampler.close();\n    });\n\n    it('should provide minimum throughput', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 0);\n\n        let expectedTags = {'sampler.type': 'lowerbound', 'sampler.param': 0};\n        [true, true, false].forEach((expectedDecision) => {\n            let actualTags = {};\n            let decision = sampler.isSampled('testOperationName', actualTags);\n            // We asked for 2 traces per second and 0% probability for the rest.\n            // Since the test runs under one second, we expect 2 successful samples\n            // and one unsuccessful.\n            if (expectedDecision) {\n                assert.isOk(decision, 'must sample');\n                assert.deepEqual(expectedTags, actualTags);\n            } else {\n                assert.isNotOk(decision, 'must not sample');\n                assert.deepEqual({}, actualTags);\n            }\n        });\n\n        sampler.close();\n    });\n\n    let assertValues = function assertValues(sampler, lb, rate) {\n        assert.equal(lb, sampler._lowerBoundSampler.maxTracesPerSecond);\n        assert.equal(rate, sampler._probabilisticSampler.samplingRate);\n    };\n\n    it('should not change when update() called with the same values', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 1.0);\n        assertValues(sampler, 2, 1.0);\n\n        let p1 = sampler._probabilisticSampler;\n        let p2 = sampler._lowerBoundSampler;\n        let isUpdated: boolean = sampler.update(2, 1.0);\n        assert.isFalse(isUpdated);\n        assert.strictEqual(sampler._probabilisticSampler, p1);\n        assert.strictEqual(sampler._lowerBoundSampler, p2);\n        assertValues(sampler, 2, 1.0);\n    });\n\n    it('should update only lower bound', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 1.0);\n        assertValues(sampler, 2, 1.0);\n\n        // should only change lower bound\n        let p1 = sampler._probabilisticSampler;\n        let p2 = sampler._lowerBoundSampler;\n        let isUpdated: boolean = sampler.update(3, 1.0);\n        assert.isTrue(isUpdated);\n        assert.strictEqual(sampler._probabilisticSampler, p1);\n        assert.isNotOk(p2 === sampler._lowerBoundSampler);\n        assertValues(sampler, 3, 1.0);\n    });\n\n    it('should update only sampling rate', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 1.0);\n        assertValues(sampler, 2, 1.0);\n\n        let p1 = sampler._probabilisticSampler;\n        let p2 = sampler._lowerBoundSampler;\n        let isUpdated: boolean = sampler.update(2, 0.9);\n        assert.isTrue(isUpdated);\n        assert.isNotOk(p1 === sampler._probabilisticSampler);\n        assert.strictEqual(sampler._lowerBoundSampler, p2);\n        assertValues(sampler, 2, 0.9);\n    });\n\n    it('should become probabilistic after minimum throughput', () => {\n        let sampler = new GuaranteedThroughputSampler(2, 1.0);\n\n        let expectedTagsLB = {'sampler.type': 'lowerbound', 'sampler.param': 0.0};\n        let expectedTagsProb = {'sampler.type': 'probabilistic', 'sampler.param': 1.0};\n\n        // The sampler is setup with 2 traces per second and 100% probability otherwise.\n        // The 100% probability takes precedence over lower-bound, so we manipulate\n        // the probability for every iteration.\n        [\n            // 100% probability triggers probabilistic sampler\n            {num: 1, probability: 1, sampled: true, tags: expectedTagsProb},\n            // 0% probability triggers lower-bound sampler\n            {num: 2, probability: 0, sampled: true, tags: expectedTagsLB},\n            // 0% probability results in sampled=false because rate limit was reached \n            {num: 3, probability: 0, sampled: false, tags: {}},\n            // 100% probability triggers probabilitic sampler again\n            {num: 4, probability: 1, sampled: true, tags: expectedTagsProb}\n        ].forEach((testCase) => {\n            // override probability, and do a sanity check\n            let s = sampler._lowerBoundSampler;\n            sampler.update(2, testCase.probability);\n            assert.strictEqual(s, sampler._lowerBoundSampler, 'lower bound sampled unchanged');\n            assert.equal(sampler._probabilisticSampler.samplingRate, testCase.probability);\n\n            let expectedDecision = testCase.sampled;\n            let expectedTags = testCase.tags;\n\n            let actualTags = {};\n            let decision = sampler.isSampled('testOperationName', actualTags);\n            if (expectedDecision) {\n                assert.isOk(decision, `must sample, test case ${testCase.num}`);\n                assert.deepEqual(expectedTags, actualTags, `must match tags, test case ${testCase.num}`);\n            } else {\n                assert.isNotOk(decision, `must not sample, test case ${testCase.num}`);\n                assert.deepEqual({}, actualTags, `must not have tags, test case ${testCase.num}`);\n            }\n        });\n\n        sampler.close();\n    });\n});\n"]}