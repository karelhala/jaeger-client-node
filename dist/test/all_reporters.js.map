{"version":3,"sources":["../../test/all_reporters.js"],"names":["describe","reporters","beforeEach","loggingReporter","inMemoryReporter","setProcess","noopReporter","sender","_process","remoteReporter","it","compositeReporter","equal","name","closeOptions","callback","spy","predicate","calledOnce","each","o","reporter","close","isOk","logger","spanMock","key","report","_infoMsgs","mockReporter"],"mappings":";;AAoBA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AA7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAaAA,SAAS,sBAAT,EAAiC,YAAM;AACnC,QAAIC,kBAAJ;AACAC,eAAW,YAAM;AACb,YAAIC,kBAAkB,gCAAtB;AACA,YAAIC,mBAAmB,kCAAvB;AACAA,yBAAiBC,UAAjB,CAA4B,cAA5B,EAA4C,EAA5C;AACA,YAAIC,eAAe,6BAAnB;AACA,YAAIC,SAAS,0BAAb;AACAA,eAAOF,UAAP,CAAkBD,iBAAiBI,QAAnC;AACA,YAAIC,iBAAiB,8BAAmBF,MAAnB,CAArB;AACAN,oBAAY,CACRE,eADQ,EAERC,gBAFQ,EAGRE,YAHQ,EAIRG,cAJQ,CAAZ;AAMH,KAdD;;AAgBAC,OAAI,mBAAJ,EAAyB,YAAM;AAC3B,YAAIP,kBAAkB,gCAAtB;AACA,YAAIC,mBAAmB,kCAAvB;AACAA,yBAAiBC,UAAjB,CAA4B,cAA5B,EAA4C,EAA5C;AACA,YAAIC,eAAe,6BAAnB;AACA,YAAIG,iBAAiB,8BAAmB,0BAAnB,CAArB;AACA,YAAIE,oBAAoB,kCAAxB;;AAEA,qBAAOC,KAAP,CAAaT,gBAAgBU,IAAhB,EAAb,EAAqC,iBAArC;AACA,qBAAOD,KAAP,CAAaR,iBAAiBS,IAAjB,EAAb,EAAsC,kBAAtC;AACA,qBAAOD,KAAP,CAAaN,aAAaO,IAAb,EAAb,EAAkC,cAAlC;AACA,qBAAOD,KAAP,CAAaH,eAAeI,IAAf,EAAb,EAAoC,gBAApC;AACA,qBAAOD,KAAP,CAAaD,kBAAkBE,IAAlB,EAAb,EAAuC,mBAAvC;AACH,KAbD;;AAeA,QAAIC,eAAe,CACf,EAAEC,UAAU,gBAAMC,GAAN,EAAZ,EAAyBC,WAAW,mBAACD,GAAD,EAAS;AAAE,mBAAOA,IAAIE,UAAJ,KAAmB,IAA1B;AAAiC,SAAhF,EADe,EAEf,EAAEH,UAAU,IAAZ,EAAkBE,WAAW,mBAACD,GAAD,EAAS;AAAE,mBAAO,IAAP;AAAc,SAAtD,EAFe,CAAnB;;AAKA,qBAAEG,IAAF,CAAOL,YAAP,EAAqB,UAACM,CAAD,EAAO;AACxBV,WAAI,2CAAJ,EAAiD,YAAM;AACnD,gBAAIW,WAAW,iCAAsBpB,SAAtB,CAAf;;AAEAoB,qBAASC,KAAT,CAAeF,EAAEL,QAAjB;;AAEA,yBAAOQ,IAAP,CAAYH,EAAEH,SAAF,CAAYG,EAAEL,QAAd,CAAZ;AACH,SAND;AAOH,KARD;;AAUAf,aAAS,kBAAT,EAA6B,YAAM;AAC/BU,WAAG,+CAAH,EAAoD,YAAM;AACtD,gBAAIc,SAAS,2BAAb;AACA,gBAAIH,WAAW,+BAAoBG,MAApB,CAAf;AACA,gBAAIC,WAAW,EAAEC,KAAK,WAAP,EAAf;;AAEAL,qBAASM,MAAT,CAAgBF,QAAhB;;AAEA,yBAAOb,KAAP,CAAaY,OAAOI,SAAP,CAAiB,CAAjB,CAAb,EAAkC,oCAAlC;AACH,SARD;AASH,KAVD;;AAYA5B,aAAS,oBAAT,EAA+B,YAAM;AACjCU,WAAI,qBAAJ,EAA2B,YAAM;AAC7B,gBAAImB,eAAe;AACfF,wBAAQ,gBAAMX,GAAN;AADO,aAAnB;AAGA,gBAAIK,WAAW,iCAAsB,CAACQ,YAAD,CAAtB,CAAf;AACAR,qBAASM,MAAT;;AAEA,yBAAOJ,IAAP,CAAYM,aAAaF,MAAb,CAAoBT,UAAhC;AACH,SARD;AASH,KAVD;AAWH,CAvED","file":"all_reporters.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport _ from 'lodash';\nimport { assert } from 'chai';\nimport CompositeReporter from '../src/reporters/composite_reporter';\nimport InMemoryReporter from '../src/reporters/in_memory_reporter';\nimport NoopReporter from '../src/reporters/noop_reporter';\nimport RemoteReporter from '../src/reporters/remote_reporter';\nimport UDPSender from '../src/reporters/udp_sender';\nimport MockLogger from './lib/mock_logger';\nimport LoggingReporter from '../src/reporters/logging_reporter';\nimport sinon from 'sinon';\n\ndescribe('All Reporters should', () => {\n    let reporters;\n    beforeEach(() => {\n        let loggingReporter = new LoggingReporter();\n        let inMemoryReporter = new InMemoryReporter();\n        inMemoryReporter.setProcess('service-name', []);\n        let noopReporter = new NoopReporter();\n        let sender = new UDPSender();\n        sender.setProcess(inMemoryReporter._process);\n        let remoteReporter = new RemoteReporter(sender);\n        reporters = [\n            loggingReporter,\n            inMemoryReporter,\n            noopReporter,\n            remoteReporter\n        ];\n    });\n\n    it ('have proper names', () => {\n        let loggingReporter = new LoggingReporter();\n        let inMemoryReporter = new InMemoryReporter();\n        inMemoryReporter.setProcess('service-name', []);\n        let noopReporter = new NoopReporter();\n        let remoteReporter = new RemoteReporter(new UDPSender());\n        let compositeReporter = new CompositeReporter();\n\n        assert.equal(loggingReporter.name(), 'LoggingReporter');\n        assert.equal(inMemoryReporter.name(), 'InMemoryReporter');\n        assert.equal(noopReporter.name(), 'NoopReporter');\n        assert.equal(remoteReporter.name(), 'RemoteReporter');\n        assert.equal(compositeReporter.name(), 'CompositeReporter');\n    });\n\n    let closeOptions = [\n        { callback: sinon.spy(), predicate: (spy) => { return spy.calledOnce === true; }},\n        { callback: null, predicate: (spy) => { return true; }}\n    ];\n\n    _.each(closeOptions, (o) => {\n        it ('calls to close execute callback correctly', () => {\n            let reporter = new CompositeReporter(reporters);\n\n            reporter.close(o.callback);\n\n            assert.isOk(o.predicate(o.callback));\n        });\n    });\n\n    describe('Logging reporter', () => {\n        it('report span logs span as a stringified object', () => {\n            let logger = new MockLogger();\n            let reporter = new LoggingReporter(logger);\n            let spanMock = { key: 'some-span' };\n\n            reporter.report(spanMock);\n\n            assert.equal(logger._infoMsgs[0], 'Reporting span {\"key\":\"some-span\"}');\n        });\n    });\n\n    describe('Composite reporter', () => {\n        it ('should report spans', () => {\n            let mockReporter = {\n                report: sinon.spy()\n            };\n            let reporter = new CompositeReporter([mockReporter]);\n            reporter.report();\n\n            assert.isOk(mockReporter.report.calledOnce);\n        });\n    });\n});\n"]}