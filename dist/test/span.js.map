{"version":3,"sources":["../../test/span.js"],"names":["constants","opentracing","thrift","describe","reporter","tracer","span","spanContext","beforeEach","logger","withBinaryIds","encodeInt64","SAMPLED_MASK","now","it","equal","context","setOperationName","operationName","initialDate","Date","getTime","_startTime","expectedDuration","finishDate","finish","_duration","spans","length","spanInfo","toString","_logger","_errorMsgs","_setSamplingPriority","isOk","isDebug","isSampled","isNotOk","keyValuePairs","numberTag","stringTag","booleanTag","addTags","count","i","_tags","key","timestamp","event","log","_logs","fields","value","payload","a","JSON","stringify","expectedTimestamp","clock","useFakeTimers","restore","setBaggageItem","getBaggageItem","child","startSpan","childOf","unnormalizedKey","_normalizeBaggageKey","_getBaggageHeaderCache","_flags","DEFERRED_SAMPLING_MASK","notEqual","flags","_spanContext","samplingFinalized","mockSampler","mock","_sampler","expects","withExactArgs","returns","verify","options","desc","sampling","reportedSpans","each","o","setTag","deepEqual","childSpan","Tags","SAMPLING_PRIORITY","unsampledSpan","headers","inject","FORMAT_HTTP_HEADERS","unFinalizedSpan","_isWriteable","sampledSpan","hasTags","newSpan","isEqual"],"mappings":"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","file":"span.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport _ from 'lodash';\nimport {assert, expect} from 'chai';\nimport ConstSampler from '../src/samplers/const_sampler.js';\nimport ProbabilisticSampler from '../src/samplers/probabilistic_sampler';\nimport * as constants from '../src/constants.js';\nimport InMemoryReporter from '../src/reporters/in_memory_reporter.js';\nimport JaegerTestUtils from '../src/test_util';\nimport MockLogger from './lib/mock_logger';\nimport * as opentracing from 'opentracing';\nimport Span from '../src/span.js';\nimport SpanContext from '../src/span_context.js';\nimport sinon from 'sinon';\nimport * as thrift from '../src/thrift.js';\nimport Tracer from '../src/tracer.js';\nimport Utils from '../src/util.js';\n\ndescribe('span should', () => {\n    let reporter = new InMemoryReporter();\n    let tracer, span, spanContext;\n\n    beforeEach(() => {\n        tracer = new Tracer(\n            'test-service-name',\n            reporter,\n            new ConstSampler(true),\n            { logger: new MockLogger() }\n        );\n\n        spanContext = SpanContext.withBinaryIds(\n            Utils.encodeInt64(1),\n            Utils.encodeInt64(2),\n            Utils.encodeInt64(3),\n            constants.SAMPLED_MASK\n        );\n\n        span = new Span(\n            tracer,\n            'op-name',\n            spanContext,\n            tracer.now()\n        );\n    });\n\n    it('return span context when context() is called', () => {\n        assert.equal(span.context(), spanContext);\n    });\n\n    it('return tracer when tracer() is called', () => {\n        assert.equal(span.tracer(), tracer);\n    });\n\n    it('set operation name correctly', () => {\n        span.setOperationName('operation-name');\n        assert.equal(span.operationName, 'operation-name');\n    });\n\n    it('finish span with custom duration', () => {\n        let initialDate = new Date(2011, 9, 1).getTime();\n        span._startTime = initialDate;\n        let expectedDuration = 1000;\n        let finishDate = initialDate + expectedDuration;\n\n        span.finish(finishDate);\n\n        assert.equal(span._duration, expectedDuration);\n        assert.equal(reporter.spans.length, 1);\n        assert.equal(reporter.spans[0], span);\n    });\n\n    it('finish span twice logs error', () => {\n        span.finish();\n        span.finish();\n        let spanInfo = `operation=${span.operationName},context=${span.context().toString()}`;\n        assert.equal(tracer._logger._errorMsgs[0], `${spanInfo}#You can only call finish() on a span once.`);\n    });\n\n    it('set debug and sampling version through sampling priority', () => {\n        span._setSamplingPriority(3);\n\n        assert.isOk(span.context().isDebug());\n        assert.isOk(span.context().isSampled());\n    });\n\n    it('unset sampling on span', () => {\n        span._setSamplingPriority(0);\n\n        assert.isNotOk(span.context().isSampled());\n    });\n\n    it('add tags', () => {\n        let keyValuePairs = {\n            numberTag: 7,\n            stringTag: 'string',\n            booleanTag: true,\n        };\n        span.addTags(keyValuePairs);\n        span.addTags({numberTag: 8});\n\n        // test to make sure consecutive calls with same key does not\n        // overwrite the first key.\n        let count = 0;\n        for(let i = 0; i < span._tags.length; i++) {\n            if (span._tags[i].key === 'numberTag') {\n                count += 1;\n            }\n        }\n\n        assert.isOk(span._tags.length, 4);\n        assert.equal(count, 2);\n    });\n\n    it('add logs with timestamp, and event', () => {\n        let timestamp = new Date(2016, 8, 12).getTime();\n        let event = 'some messgae';\n        span.log({ 'event': event }, timestamp);\n\n        assert.equal(span._logs.length, 1);\n        assert.equal(span._logs[0].timestamp, timestamp);\n        assert.equal(span._logs[0].fields[0].value, event);\n    });\n\n    it('add logs with paylaod', () => {\n        let payload = {a: 1};\n        span.log({payload});\n\n        assert.equal(span._logs.length, 1);\n        assert.equal(JSON.stringify(span._logs[0].fields[0].value), JSON.stringify(payload));\n    });\n\n    it('add logs with event, but without timestamp', () => {\n        let expectedTimestamp = 123.456;\n        // mock global clock\n        let clock = sinon.useFakeTimers(expectedTimestamp);\n        let event = 'some messgae';\n        span.log({ event });\n\n        assert.equal(span._logs.length, 1);\n        assert.equal(span._logs[0].timestamp, expectedTimestamp);\n        assert.equal(span._logs[0].fields[0].value, event);\n        clock.restore();\n    });\n\n    it ('set and retrieve baggage correctly', () => {\n        let key = 'some-key';\n        let value = 'some-value';\n\n        span.setBaggageItem(key, value);\n        assert.equal(value, span.getBaggageItem(key));\n    });\n\n    it ('inherit baggage from parent', () => {\n        let key = 'some-key';\n        let value = 'some-value';\n\n        span.setBaggageItem(key, value);\n        let child = tracer.startSpan('child', { childOf: span.context() });\n        assert.equal(value, child.getBaggageItem(key));\n    });\n\n    it ('normalized key correctly', () => {\n        let unnormalizedKey = 'SOME_KEY';\n        let key = span._normalizeBaggageKey(unnormalizedKey);\n\n        assert.equal(key, 'some-key');\n        assert.isOk(unnormalizedKey in Span._getBaggageHeaderCache());\n    });\n\n    describe('with deferred sampling', () => {\n        beforeEach(function () {\n            spanContext._flags = constants.DEFERRED_SAMPLING_MASK;\n        });\n        it('should not pass deferred sampling flag to child spans', () => {\n            let child = tracer.startSpan('child', {childOf: span.context()});\n            assert.notEqual(child.context.flags & constants.DEFERRED_SAMPLING_MASK,\n                            constants.DEFERRED_SAMPLING_MASK);\n            assert.isOk(child._spanContext.samplingFinalized);\n        });\n\n        it('should make a call to the underlying sampler and use the sampling decision when true', () => {\n            let mockSampler = sinon.mock(tracer._sampler);\n            mockSampler.expects('isSampled').withExactArgs('goodOperation', {}).returns(true);\n            let child = tracer.startSpan('goodOperation', {childOf: span.context()});\n            mockSampler.verify();\n            assert.isOk(child.context().isSampled());\n        });\n\n        it('should make a call to the underlying sampler and use the sampling decision when false', () => {\n            let mockSampler = sinon.mock(tracer._sampler);\n            mockSampler.expects('isSampled').withExactArgs('horridOperation', {}).returns(false);\n            let child = tracer.startSpan('horridOperation', {childOf: span.context()});\n            mockSampler.verify();\n            assert.isNotOk(child.context().isSampled());\n        });\n    });\n\n    describe('adaptive sampling tests for span', () => {\n        let options = [\n            { desc: 'sampled: ', sampling: true, reportedSpans: 1 },\n            { desc: 'unsampled: ', sampling: false, reportedSpans: 0}\n        ];\n        _.each(options, (o) => {\n            it (o.desc + 'should save tags, and logs on an unsampled span incase it later becomes sampled', () => {\n                let reporter = new InMemoryReporter();\n                let tracer = new Tracer(\n                    'test-service-name',\n                    reporter,\n                    new ConstSampler(false),\n                    { logger: new MockLogger() }\n                );\n                let span = tracer.startSpan('initially-unsampled-span');\n                span.setTag('tagKeyOne', 'tagValueOne');\n                span.addTags({\n                    'tagKeyTwo': 'tagValueTwo'\n                });\n                span.log({'logkeyOne': 'logValueOne'});\n\n                tracer._sampler = new ConstSampler(o.sampling);\n                span.setOperationName('sampled-span');\n                span.finish();\n\n                assert.deepEqual(span._tags[0], {key: 'tagKeyOne', value: 'tagValueOne'});\n                assert.deepEqual(span._tags[1], {key: 'tagKeyTwo', value: 'tagValueTwo'});\n                assert.deepEqual(span._logs[0].fields[0], {key: 'logkeyOne', value: 'logValueOne'});\n                assert.equal(reporter.spans.length, o.reportedSpans);\n            });\n        });\n\n        describe('span sampling finalizer', () => {\n            it ('should trigger when it inherits a sampling decision', () => {\n                assert.equal(span.context().samplingFinalized, false, 'Span created in before each is not finalized');\n\n                let childSpan = tracer.startSpan('child-span', {childOf: span});\n                assert.isOk(span.context().samplingFinalized);\n                assert.isOk(childSpan.context().samplingFinalized);\n            });\n\n            it ('should trigger when it sets the sampling priority', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                span.setTag(opentracing.Tags.SAMPLING_PRIORITY, 1);\n                assert.isOk(span.context().samplingFinalized);\n\n                let unsampledSpan = tracer.startSpan('usampled-span');\n                unsampledSpan.setTag(opentracing.Tags.SAMPLING_PRIORITY, -1);\n                assert.isOk(unsampledSpan.context().samplingFinalized);\n            });\n\n            it ('should trigger on a finish()-ed span', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                span.finish();\n                assert.isOk(span.context().samplingFinalized);\n            });\n\n            it ('should trigger after calling setOperationName', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                span.setOperationName('fry');\n                assert.isOk(span.context().samplingFinalized);\n            });\n\n            it ('should trigger when its context is injected into headers', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                let headers = {};\n                tracer.inject(span.context(), opentracing.FORMAT_HTTP_HEADERS, headers);\n\n                assert.isOk(span.context().samplingFinalized);\n            });\n        });\n\n        it ('isWriteable returns true if not finalized, or the span is sampled', () => {\n            tracer = new Tracer(\n                'test-service-name',\n                new InMemoryReporter(),\n                new ConstSampler(false),\n                { logger: new MockLogger() }\n            );\n            let unFinalizedSpan = tracer.startSpan('unFinalizedSpan');\n            assert.equal(unFinalizedSpan.context().samplingFinalized, false);\n            assert.isOk(unFinalizedSpan._isWriteable());\n\n            tracer._sampler = new ConstSampler(true);\n            let sampledSpan = tracer.startSpan('sampled-span');\n\n            sampledSpan.finish();  // finalizes the span\n            assert.isOk(sampledSpan.context().samplingFinalized);\n\n            assert.isOk(sampledSpan._isWriteable());\n        });\n\n        it ('2nd setOperationName should add sampler tags to span, and change operationName', () => {\n            let span = tracer.startSpan('fry');\n\n            assert.equal(span.operationName, 'fry');\n            assert.isOk(JaegerTestUtils.hasTags(span, {\n                'sampler.type': 'const',\n                'sampler.param': true\n            }));\n            tracer._sampler = new ProbabilisticSampler(1.0);\n            span.setOperationName('re-sampled-span');\n\n            assert.equal(span.operationName, 're-sampled-span');\n            assert.isOk(JaegerTestUtils.hasTags(span, {\n                'sampler.type': 'probabilistic',\n                'sampler.param': 1\n            }));\n        });\n\n        it ('2nd setOperationName should not change the sampling tags, but should change the operationName', () => {\n            let span = tracer.startSpan('fry');\n\n            span.setOperationName('new-span-one');\n            assert.equal(span.operationName, 'new-span-one');\n\n            // update sampler to something will always sample\n            tracer._sampler = new ProbabilisticSampler(1.0);\n\n            // The second cal lshould rename the operation name, but\n            // not re-sample the span.  This is because finalize was set\n            // in the first 'setOperationName' call.\n            span.setOperationName('new-span-two');\n\n            assert.equal(span.operationName, 'new-span-two');\n            assert.isOk(JaegerTestUtils.hasTags(span, {\n                'sampler.type': 'const',\n                'sampler.param': true\n            }));\n        });\n    });\n\n    describe('setTag', () => {\n        it('should set a tag, and return a span', () => {\n            var newSpan = span.setTag('key', 'value');\n            assert.isOk(newSpan instanceof Span);\n            assert.isOk(_.isEqual(span._tags[0], {'key': 'key', 'value': 'value'}));\n        });\n    })\n\n    // TODO(oibe) need tests for standard tags, and handlers\n});\n\n"]}