{"version":3,"sources":["../../src/tracer.js"],"names":["constants","opentracing","Tracer","serviceName","reporter","sampler","options","_tags","tags","JAEGER_CLIENT_VERSION_TAG_KEY","version","TRACER_HOSTNAME_TAG_KEY","hostname","Tags","PEER_HOST_IPV4","ipToInt","myIp","_metrics","metrics","_serviceName","_reporter","_sampler","_logger","logger","_injectors","_extractors","textCodec","urlEncoding","registerInjector","FORMAT_TEXT_MAP","registerExtractor","httpCodec","FORMAT_HTTP_HEADERS","binaryCodec","FORMAT_BINARY","setProcess","convertObjectToTags","spanContext","operationName","startTime","userTags","internalTags","parentContext","rpcServer","references","hadParent","isDebugIDContainerOnly","span","addTags","spansStarted","increment","context","isSampled","spansSampled","tracesStartedSampled","tracesJoinedSampled","spansNotSampled","tracesStartedNotSampled","tracesJoinedNotSampled","spansFinished","report","format","injector","extractor","now","followsFromIsParent","parent","childOf","i","length","ref","type","REFERENCE_CHILD_OF","referencedContext","REFERENCE_FOLLOWS_FROM","spanKindValue","SPAN_KIND","SPAN_KIND_RPC_SERVER","ctx","isValid","randomId","getRandom64","flags","SAMPLED_MASK","DEBUG_MASK","JAEGER_DEBUG_HEADER","debugId","baggage","traceId","spanId","parentId","finalizeSampling","processDeferredSampling","_startInternalSpan","isDeferredSampling","_flags","unsetDeferredSampling","carrier","Error","inject","extract","callback","close","Date"],"mappings":"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","file":"tracer.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport BinaryCodec from './propagators/binary_codec';\nimport ConstSampler from './samplers/const_sampler';\nimport * as constants from './constants';\nimport * as opentracing from 'opentracing';\nimport pjson from '../package.json';\nimport {Tags as opentracing_tags} from 'opentracing';\nimport NoopReporter from './reporters/noop_reporter';\nimport Span from './span';\nimport SpanContext from './span_context';\nimport TextMapCodec from './propagators/text_map_codec';\nimport NullLogger from './logger';\nimport Utils from './util';\nimport Metrics from './metrics/metrics';\nimport NoopMetricFactory from './metrics/noop/metric_factory';\nimport os from 'os';\n\nexport default class Tracer {\n    _serviceName: string;\n    _reporter: Reporter;\n    _sampler: Sampler;\n    _logger: NullLogger;\n    _tags: any;\n    _injectors: any;\n    _extractors: any;\n    _metrics: any;\n\n    /**\n     * @param {String} [serviceName] - name of the current service or application.\n     * @param {Object} [reporter] - reporter used to submit finished spans to Jaeger backend.\n     * @param {Object} [sampler] - sampler used to decide if trace should be sampled when starting a new one.\n     * @param {Object} [options] - the fields to set on the newly created span.\n     * @param {Object} [options.tags] - set of key-value pairs which will be set\n     *        as process-level tags on the Tracer itself.\n     * @param {Object} [options.metrics] - instance of the Metrics class from ./metrics/metrics.js.\n     * @param {Object} [options.logger] - a logger matching NullLogger API from ./logger.js.\n     */\n    constructor(serviceName: string,\n            reporter: Reporter = new NoopReporter(),\n            sampler: Sampler = new ConstSampler(false),\n            options: any = {}) {\n        this._tags = options.tags || {};\n        this._tags[constants.JAEGER_CLIENT_VERSION_TAG_KEY] = `Node-${pjson.version}`;\n        this._tags[constants.TRACER_HOSTNAME_TAG_KEY] = os.hostname();\n        this._tags[opentracing.Tags.PEER_HOST_IPV4] = Utils.ipToInt(Utils.myIp());\n\n        this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n\n        this._serviceName = serviceName;\n        this._reporter = reporter;\n        this._sampler = sampler;\n        this._logger = options.logger || new NullLogger();\n        this._injectors = {};\n        this._extractors = {};\n\n        let textCodec = new TextMapCodec({\n            urlEncoding: false,\n            metrics: this._metrics\n        });\n        this.registerInjector(opentracing.FORMAT_TEXT_MAP, textCodec);\n        this.registerExtractor(opentracing.FORMAT_TEXT_MAP, textCodec);\n\n        let httpCodec = new TextMapCodec({\n            urlEncoding: true,\n            metrics: this._metrics\n        });\n        this.registerInjector(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n        this.registerExtractor(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n\n        let binaryCodec = new BinaryCodec();\n        this.registerInjector(opentracing.FORMAT_BINARY, binaryCodec);\n        this.registerExtractor(opentracing.FORMAT_BINARY, binaryCodec);\n\n        this._reporter.setProcess(this._serviceName, Utils.convertObjectToTags(this._tags));\n    }\n\n    _startInternalSpan(\n        spanContext: SpanContext,\n        operationName: string,\n        startTime: number,\n        userTags: any,\n        internalTags: any,\n        parentContext: ?SpanContext,\n        rpcServer: boolean,\n        references: Array<Reference>): Span {\n\n        let hadParent = parentContext && !parentContext.isDebugIDContainerOnly();\n        let span = new Span(\n            this,\n            operationName,\n            spanContext,\n            startTime,\n            references\n        );\n\n        span.addTags(userTags);\n        span.addTags(internalTags);\n\n        // emit metrics\n        this._metrics.spansStarted.increment(1);\n        if (span.context().isSampled()) {\n            this._metrics.spansSampled.increment(1);\n            if (!hadParent) {\n                this._metrics.tracesStartedSampled.increment(1);\n            } else if (rpcServer) {\n                this._metrics.tracesJoinedSampled.increment(1);\n            }\n        } else {\n            this._metrics.spansNotSampled.increment(1);\n            if (!hadParent) {\n                this._metrics.tracesStartedNotSampled.increment(1);\n            } else if (rpcServer) {\n                this._metrics.tracesJoinedNotSampled.increment(1);\n            }\n        }\n\n        return span;\n    }\n\n    _report(span: Span): void {\n        this._metrics.spansFinished.increment(1);\n        this._reporter.report(span);\n    }\n\n    registerInjector(format: string, injector: Injector): void {\n        this._injectors[format] = injector;\n    }\n\n    registerExtractor(format: string, extractor: Extractor): void {\n        this._extractors[format] = extractor;\n    }\n\n    /**\n    * The method for creating a root or child span.\n    *\n    * @param {string} operationName - the name of the operation.\n    * @param {object} [options] - the fields to set on the newly created span.\n    * @param {string} options.operationName - the name to use for the newly\n    *        created span. Required if called with a single argument.\n    * @param {SpanContext} [options.childOf] - a parent SpanContext (or Span,\n    *        for convenience) that the newly-started span will be the child of\n    *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n    *        be unspecified.\n    * @param {array} [options.references] - an array of Reference instances,\n    *        each pointing to a causal parent SpanContext. If specified,\n    *        `fields.childOf` must be unspecified.\n    * @param {object} [options.tags] - set of key-value pairs which will be set\n    *        as tags on the newly created Span. Ownership of the object is\n    *        passed to the created span for efficiency reasons (the caller\n    *        should not modify this object after calling startSpan).\n    * @param {number} [options.startTime] - a manually specified start time for\n    *        the created Span object. The time should be specified in\n    *        milliseconds as Unix timestamp. Decimal value are supported\n    *        to represent time values with sub-millisecond accuracy.\n    * @return {Span} - a new Span object.\n    **/\n    startSpan(operationName: string, options: ?startSpanOptions): Span {\n        // Convert options.childOf to options.references as needed.\n        options = options || {};\n        let references = options.references || [];\n\n        let userTags = options.tags || {};\n        let startTime = options.startTime || this.now();\n\n        // This flag is used to ensure that CHILD_OF reference is preferred \n        // as a parent even if it comes after FOLLOWS_FROM reference.\n        let followsFromIsParent = false;\n        let parent: ?SpanContext = options.childOf instanceof Span ? options.childOf.context() : options.childOf;\n        // If there is no childOf in options, then search list of references\n        for (let i = 0; i < references.length; i++) {\n            let ref: Reference = references[i];\n            if (ref.type() === opentracing.REFERENCE_CHILD_OF) {\n                if (!parent || followsFromIsParent) {\n                    parent = ref.referencedContext();\n                    break;\n                }\n            } else if (ref.type() === opentracing.REFERENCE_FOLLOWS_FROM) {\n                if (!parent) {\n                    parent = ref.referencedContext();\n                    followsFromIsParent = true;\n                }\n            }\n        }\n\n        let spanKindValue = userTags[opentracing_tags.SPAN_KIND];\n        let rpcServer = (spanKindValue === opentracing_tags.SPAN_KIND_RPC_SERVER);\n\n        let ctx: SpanContext = new SpanContext();\n        let internalTags: any = {};\n        if (!parent || !parent.isValid) {\n            let randomId = Utils.getRandom64();\n            let flags = 0;\n            if (this._sampler.isSampled(operationName, internalTags)) {\n                flags |= constants.SAMPLED_MASK;\n            }\n\n            if (parent) {\n                if (parent.isDebugIDContainerOnly()) {\n                    flags |= (constants.SAMPLED_MASK | constants.DEBUG_MASK);\n                    internalTags[constants.JAEGER_DEBUG_HEADER] = parent.debugId;\n                }\n                // baggage that could have been passed via `jaeger-baggage` header\n                ctx.baggage = parent.baggage;\n            }\n\n            ctx.traceId = randomId;\n            ctx.spanId = randomId;\n            ctx.parentId = null;\n            ctx.flags = flags;\n        } else {\n            ctx.traceId = parent.traceId;\n            ctx.spanId = Utils.getRandom64();\n            ctx.parentId = parent.spanId;\n            ctx.flags = parent.flags;\n\n            // reuse parent's baggage as we'll never change it\n            ctx.baggage = parent.baggage;\n\n            parent.finalizeSampling();\n            this.processDeferredSampling(ctx, operationName, internalTags);\n            ctx.finalizeSampling();\n        }\n\n        return this._startInternalSpan(\n            ctx,\n            operationName,\n            startTime,\n            userTags,\n            internalTags,\n            parent,\n            rpcServer,\n            references\n        );\n    }\n\n    /**\n     *  Makes a concrete sampling decision for the ctx span context based on information\n     *  available to it's child span.\n     *\n     *  The ctx context's deferred mask is unset after this decision is made\n     *\n     * @param ctx the span context\n     * @param operationName the operation name for the child\n     * @param tags tags to be applied by the sampler\n     */\n    processDeferredSampling(ctx: SpanContext, operationName: string, tags: any) {\n        if (ctx.isDeferredSampling) {\n            if (this._sampler.isSampled(operationName, tags)) {\n                ctx._flags |= constants.SAMPLED_MASK;\n            } else {\n                ctx._flags &= ~constants.SAMPLED_MASK;\n            }\n            ctx.unsetDeferredSampling();\n        }\n    }\n\n    /**\n     * Saves the span context into the carrier object for various formats, and encoders.\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     **/\n    inject(spanContext: SpanContext, format: string, carrier: any): void {\n        if (!spanContext) {\n            return;\n        }\n\n        let injector = this._injectors[format];\n        if (!injector) {\n            throw new Error(`Unsupported format: ${format}`);\n        }\n\n        if (spanContext.context) {\n            spanContext = spanContext.context();\n        }\n\n        spanContext.finalizeSampling();\n        injector.inject(spanContext, carrier);\n    }\n\n    /**\n    * Responsible for extracting a span context from various serialized formats.\n    *\n    * @param  {string} format - the format of the carrier.\n    * @param  {any} carrier - the type of the carrier object is determined by\n    *         the format.\n    * @return {SpanContext}\n    *         The extracted SpanContext, or null if no such SpanContext could\n    *         be found in `carrier`\n    */\n    extract(format: string, carrier: any): SpanContext {\n        let extractor = this._extractors[format];\n        if (!extractor) {\n            throw new Error(`Unsupported format: ${format}`);\n        }\n\n        let spanContext = extractor.extract(carrier);\n\n        if (spanContext) {\n            spanContext.finalizeSampling();\n        }\n        return spanContext;\n    }\n\n    /**\n     * Closes the tracer, flushes spans, and executes any callbacks if necessary.\n     *\n     * @param {Function} [callback] - a callback that runs after the tracer has been closed.\n     **/\n    close(callback: Function): void {\n        let reporter = this._reporter;\n        this._reporter = new NoopReporter();\n        reporter.close(() => {\n            this._sampler.close(callback);\n        });\n    }\n\n    /**\n     * Returns the current timestamp in milliseconds since the Unix epoch.\n     * Fractional values are allowed so that timestamps with sub-millisecond\n     * accuracy can be represented.\n     */\n    now(): number {\n        // TODO investigate process.hrtime; verify it is available in all Node versions.\n        // http://stackoverflow.com/questions/11725691/how-to-get-a-microtime-in-node-js\n        return Date.now();\n    }\n}\n"]}