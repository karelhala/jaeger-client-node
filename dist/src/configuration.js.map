{"version":3,"sources":["../../src/configuration.js"],"names":["constants","jaegerSchema","Configuration","config","type","sampler","param","host","port","refreshIntervalMs","Error","SAMPLER_TYPE_PROBABILISTIC","SAMPLER_TYPE_RATE_LIMITING","SAMPLER_TYPE_CONST","SAMPLER_TYPE_REMOTE","serviceName","refreshInterval","options","reporterConfig","reporters","senderConfig","reporter","logSpans","push","logger","flushIntervalMs","agentHost","agentPort","sender","remoteReporter","length","disable","Tracer","_getSampler","_getReporter","info","name","metrics","tags"],"mappings":"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","file":"configuration.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport SpanContext from './span_context';\nimport Span from './span';\nimport ConstSampler from './samplers/const_sampler';\nimport InMemoryReporter from './reporters/in_memory_reporter';\nimport ProbabilisticSampler from './samplers/probabilistic_sampler';\nimport RateLimitingSampler from './samplers/ratelimiting_sampler';\nimport RemoteReporter from './reporters/remote_reporter';\nimport CompositeReporter from './reporters/composite_reporter';\nimport LoggingReporter from './reporters/logging_reporter';\nimport RemoteSampler from './samplers/remote_sampler';\nimport Metrics from './metrics/metrics';\nimport Tracer from './tracer';\nimport UDPSender from './reporters/udp_sender';\nimport opentracing from 'opentracing';\nimport * as constants from './constants.js';\n\nlet jaegerSchema = {\n    'id': '/jaeger',\n    'type': 'object',\n    'properties': {\n        'serviceName': {'type': 'string'},\n        'disable': {'type': 'boolean'},\n        'sampler': {\n            'properties': {\n                'type': {'type': 'string' },\n                'param': {'type': 'number' },\n                'host': {'type': 'string' },\n                'port': {'type': 'number' },\n                'refreshIntervalMs': {'type': 'number' }\n            },\n            'required': ['type', 'param'],\n            'additionalProperties': false\n        },\n        'reporter': {\n            'properties': {\n                'logSpans': {'type': 'boolean'},\n                'agentHost': {'type': 'string'},\n                'agentPort': {'type': 'number'},\n                'flushIntervalMs': {'type': 'number'}\n            },\n            'additionalProperties': false\n        }\n    }\n};\n\nexport default class Configuration {\n\n    static _getSampler(config) {\n        let type = config.sampler.type;\n        let param = config.sampler.param;\n        let host = config.sampler.host;\n        let port = config.sampler.port;\n        let refreshIntervalMs = config.sampler.refreshIntervalMs;\n\n        if (typeof(param) !== 'number') {\n            throw new Error(`Expecting sampler.param to be a number. Received ${param}`);\n        }\n\n        let sampler;\n        if (type === constants.SAMPLER_TYPE_PROBABILISTIC) {\n            sampler = new ProbabilisticSampler(param);\n        }\n\n        if (type === constants.SAMPLER_TYPE_RATE_LIMITING) {\n            sampler = new RateLimitingSampler(param);\n        }\n\n        if (type === constants.SAMPLER_TYPE_CONST) {\n            sampler = new ConstSampler(param === 1);\n        }\n\n        if (type === constants.SAMPLER_TYPE_REMOTE) {\n            sampler = new RemoteSampler(config.serviceName, {\n                sampler: new ProbabilisticSampler(param),\n                host: host,\n                port: port,\n                refreshInterval: refreshIntervalMs\n            });\n        }\n\n        return sampler;\n    }\n\n    static _getReporter(config, options) {\n        let reporterConfig = {};\n        let reporters = [];\n        let senderConfig = {};\n        if (config.reporter) {\n            if (config.reporter.logSpans) {\n                reporters.push(new LoggingReporter(options.logger));\n            }\n\n            if (config.reporter.flushIntervalMs) {\n                reporterConfig['bufferFlushInterval'] = config.reporter.flushIntervalMs;\n            }\n\n            if (config.reporter.agentHost) {\n                senderConfig['host'] = config.reporter.agentHost;\n            }\n\n            if (config.reporter.agentPort) {\n                senderConfig['port'] = config.reporter.agentPort;\n            }\n        }\n        let sender = new UDPSender(senderConfig);\n        let remoteReporter = new RemoteReporter(sender, reporterConfig);\n        if (reporters.length == 0) {\n            return remoteReporter;\n        }\n        reporters.push(remoteReporter);\n        return new CompositeReporter(reporters);\n    }\n\n    /**\n     * Initialize and return a new instance of Jaeger Tracer.\n     * \n     * The config dictionary is not validated for adherence to the schema above.\n     * Such validation can be performed like this:\n     * \n     *     import {Validator} from 'jsonschema';\n     * \n     *     let v = new Validator();\n     *     v.validate(config, jaegerSchema, {\n     *       throwError: true\n     *     });\n     * \n     * @param {Object} config - configuration matching the jaegerSchema definition.\n     * @param {Object} options - options\n     * @param {Object} [options.reporter] - if provided, this reporter will be used.\n     *        Otherwise a new reporter will be created according to the description\n     *        in the config.\n     * @param {Object} [options.metrics] - a metrics factory (see ./_flow/metrics.js)\n     * @param {Object} [options.logger] - a logger (see ./_flow/logger.js)\n     * @param {Object} [options.tags] - set of key-value pairs which will be set\n     *        as process-level tags on the Tracer itself.\n     */\n    static initTracer(config, options = {}) {\n        let reporters = [];\n        let reporter;\n        let sampler;\n        if (config.disable) {\n            return new opentracing.Tracer();\n        } else {\n            if (config.sampler) {\n                sampler = Configuration._getSampler(config);\n            } else {\n                sampler = new RemoteSampler(config.serviceName);\n            }\n\n            if (!options.reporter) {\n                reporter = Configuration._getReporter(config, options);\n            } else {\n                reporter = options.reporter;\n            }\n        }\n\n        if (options.logger) {\n            options.logger.info(\n                `Initializing Jaeger Tracer with ${reporter.name()} and ${sampler.name()}`\n            );\n        }\n\n        var metrics = null;\n        if (options.metrics) {\n            metrics = new Metrics(options.metrics);\n        }\n\n        return new Tracer(\n            config.serviceName,\n            reporter,\n            sampler,\n            {\n                metrics: metrics,\n                logger: options.logger,\n                tags: options.tags\n            }\n        );\n    }\n}\n"]}